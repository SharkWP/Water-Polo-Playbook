<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Water Polo PlayBook (Web)</title>

  <meta name="theme-color" content="#0b1220">
  <style>
    :root{
      --bg:#0b1220;
      --panel:#111a2e;
      --text:#e8eefc;
      --muted:#a9b5d6;
      --line:#223156;
      --accent:#69B3E7;

      --danger:#ff4d4d;
      --ok:#3ddc97;

      --poolTop:#0e4ea8;
      --poolBot:#0b3f86;

      /* marking colors */
      --twoM: rgba(255,199,44,.92);   /* yellow */
      --fiveM: rgba(255,77,77,.88);   /* red */
      --sixM: rgba(246,247,251,.92);  /* white */
      --white: rgba(246,247,251,.92);
    }

    *{ box-sizing:border-box; }
    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      color:var(--text);
      background: radial-gradient(1200px 600px at 20% -10%, #1a2c5a 0%, var(--bg) 60%);
      height:100vh;
      display:flex;
      flex-direction:column;
    }

    header{
      padding:12px 14px;
      border-bottom:1px solid var(--line);
      background: linear-gradient(180deg, rgba(17,26,46,0.9), rgba(15,23,48,0.7));
      display:flex;
      gap:10px;
      align-items:center;
      flex-wrap:wrap;
    }

    .brand{
      font-weight:900;
      letter-spacing:.3px;
      display:flex;
      gap:10px;
      align-items:center;
      user-select:none;
      margin-right:8px;
    }
    .dot{
      width:10px;height:10px;border-radius:50%;
      background:var(--accent);
      box-shadow:0 0 14px rgba(105,179,231,.7);
    }

    .toolbar{
      display:flex;
      flex-wrap:wrap;
      gap:8px;
      align-items:center;
      width:100%;
    }

    .group{
      display:flex;
      gap:8px;
      align-items:center;
      padding:6px 8px;
      border:1px solid var(--line);
      background: rgba(10,16,30,.35);
      border-radius:12px;
    }
    .group label{
      font-size:12px;
      color:var(--muted);
      user-select:none;
      margin-right:2px;
    }

    button, select, input[type="text"]{
      border:1px solid var(--line);
      background: rgba(255,255,255,.04);
      color:var(--text);
      padding:8px 10px;
      border-radius:12px;
      font-weight:700;
      cursor:pointer;
      outline:none;
      white-space:nowrap;
    }
    button:hover, select:hover{ border-color:#2f4477 }
    button:active{ transform: translateY(1px); }
    button.primary{ border-color: rgba(105,179,231,.55); background: rgba(105,179,231,.14); }
    button.danger{ border-color: rgba(255,77,77,.55); background: rgba(255,77,77,.12); }
    button.ok{ border-color: rgba(61,220,151,.55); background: rgba(61,220,151,.12); }
    button.active{ outline:2px solid rgba(105,179,231,.55); background: rgba(105,179,231,.18); }

    .chip{
      display:flex;
      gap:6px;
      align-items:center;
      padding:8px 10px;
      border-radius:12px;
      border:1px solid var(--line);
      background: rgba(255,255,255,.03);
      font-weight:800;
      user-select:none;
    }
    .chip input{ transform: translateY(1px); }

    input[type="color"]{
      width:44px; height:36px;
      border-radius:10px;
      border:1px solid var(--line);
      background: transparent;
      padding:0;
      cursor:pointer;
    }
    input[type="range"]{ accent-color: var(--accent); }

    main{
      flex:1;
      display:flex;
      gap:12px;
      padding:12px;
      min-height:0;
    }
    .left{
      flex:1;
      min-width:0;
      display:flex;
      flex-direction:column;
      gap:10px;
    }

    .boardShell{
      flex:1;
      min-height:0;
      border:1px solid var(--line);
      border-radius:18px;
      overflow:hidden;
      background: rgba(255,255,255,.03);
      position:relative;
      display:flex;
      align-items:center;
      justify-content:center;
      padding:10px;
    }

    /* Full pool: wide */
    #boardWrap{
      position:relative;
      width:min(1100px, 100%);
      border-radius:16px;
      overflow:hidden;
      background: linear-gradient(180deg, var(--poolTop), var(--poolBot));
      box-shadow: 0 18px 60px rgba(0,0,0,.35);
      transform-origin:center center;
      touch-action:none;
      isolation:isolate;
    }
    #boardWrap.full{ aspect-ratio: 16 / 9; }
    /* Half pool: square */
    #boardWrap.half{ aspect-ratio: 1 / 1; max-width:920px; }

    /* Pool white border */
    #boardWrap::before{
      content:"";
      position:absolute;
      inset:4%;
      border:3px solid rgba(246,247,251,.92);
      border-radius:12px;
      pointer-events:none;
      z-index:1;
    }

    canvas{
      position:absolute;
      inset:0;
      width:100%;
      height:100%;
    }
    #fieldCanvas{ z-index:1; pointer-events:none; }
    #drawCanvas{ z-index:2; }
    #uiCanvas{ z-index:3; pointer-events:none; }

    .tokensLayer{
      position:absolute;
      inset:0;
      z-index:4;
      touch-action:none;
    }

    .token{
      position:absolute;
      width:44px; height:44px;
      border-radius:999px;
      display:flex;
      align-items:center;
      justify-content:center;
      font-weight:1000;
      user-select:none;
      cursor:grab;
      border:2px solid rgba(255,255,255,.65);
      box-shadow: 0 10px 24px rgba(0,0,0,.25);
      transform: translate(-50%, -50%);
      will-change: transform;
    }
    .token:active{ cursor:grabbing; }

    .token.blue{ background: rgba(105,179,231,.92); color:#081226; }
    .token.white{ background: rgba(246,247,251,.95); color:#0b1220; }
    .token.ball{
      width:28px;height:28px;
      background: rgba(255,199,44,.98);
      border-color: rgba(255,255,255,.75);
      color:#111;
      font-weight:1000;
    }
    .token .num{
      font-size:16px;
      line-height:1;
      text-shadow: 0 2px 8px rgba(0,0,0,.2);
      pointer-events:none;
    }

    .right{
      width:390px;
      max-width:48vw;
      border:1px solid var(--line);
      border-radius:18px;
      background: rgba(17,26,46,.6);
      padding:12px;
      display:flex;
      flex-direction:column;
      gap:10px;
      min-height:0;
    }

    .tabs{ display:flex; gap:8px; }
    .tabs button{ flex:1; font-weight:900; }

    .tabPane{
      display:none;
      min-height:0;
      flex:1;
      overflow:hidden;
    }
    .tabPane.active{
      display:flex;
      flex-direction:column;
      gap:10px;
      min-height:0;
    }

    .panelTitle{ font-weight:1000; letter-spacing:.2px; }
    .hint{ color:var(--muted); font-size:12px; line-height:1.35; }

    .row{
      display:flex;
      gap:8px;
      align-items:center;
      flex-wrap:wrap;
    }

    .list{
      border:1px solid var(--line);
      border-radius:14px;
      background: rgba(10,16,30,.35);
      padding:8px;
      overflow:auto;
      min-height:0;
      flex:1;
    }

    .playItem{
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:10px;
      padding:8px;
      border-radius:12px;
      border:1px solid rgba(255,255,255,.06);
      margin-bottom:8px;
      background: rgba(255,255,255,.03);
    }
    .playItem:last-child{ margin-bottom:0; }
    .playName{
      font-weight:900;
      overflow:hidden;
      text-overflow:ellipsis;
      white-space:nowrap;
      max-width:210px;
    }
    .miniBtns{ display:flex; gap:6px; }
    .miniBtns button{ padding:6px 8px; border-radius:10px; font-size:12px; font-weight:900; }

    .ruleBox{
      border:1px solid rgba(255,255,255,.08);
      background: rgba(255,255,255,.03);
      border-radius:14px;
      padding:10px;
    }
    .ruleBox h3{ margin:0 0 6px 0; font-size:13px; }
    .ruleBox ul{ margin:0; padding-left:18px; }
    .ruleBox li{ margin:6px 0; font-size:12.5px; line-height:1.35; }

    .footerNote{ font-size:11px; color:var(--muted); opacity:.9; }

    @media (max-width: 980px){
      main{ flex-direction:column; }
      .right{ width:100%; max-width:none; }
    }
  </style>
</head>

<body>
<header>
  <div class="brand"><span class="dot"></span>Water Polo PlayBook (Web)</div>

  <div class="toolbar">
    <div class="group">
      <label>Mode</label>
      <button id="modeMove" class="active">Select/Move</button>
      <button id="modeArrow">Arrow</button>
      <button id="modeCircle">Circle</button>
      <button id="modeHighlight">Highlight</button>
      <button id="modeEraser">Eraser</button>
    </div>

    <div class="group">
      <label>Color</label>
      <input id="strokeColor" type="color" value="#69B3E7" />
      <label>Size</label>
      <input id="strokeSize" type="range" min="2" max="18" value="6" />
    </div>

    <div class="group">
      <button id="undoBtn">Undo</button>
      <button id="clearBtn" class="danger">Clear All</button>
    </div>

    <div class="group">
      <label>View</label>
      <select id="viewSel">
        <option value="half">Half Pool</option>
        <option value="full">Full Pool</option>
      </select>
      <button id="flipBtn">Flip Attack</button>
      <button id="pngBtn">Download PNG</button>
    </div>

    <div class="group">
      <button id="numbersBtn">Cap Numbers: On</button>
      <button id="editNumBtn" class="primary">Edit Selected #</button>
    </div>

    <div class="group">
      <button id="recordBtn" class="primary">Record</button>
      <button id="playBtn" class="ok">Play</button>
      <button id="rewindBtn">Rewind</button>
    </div>
  </div>
</header>

<main>
  <section class="left">
    <div class="boardShell">
      <div id="boardWrap" class="half">
        <canvas id="fieldCanvas"></canvas>
        <canvas id="drawCanvas"></canvas>
        <canvas id="uiCanvas"></canvas>
        <div id="tokensLayer" class="tokensLayer"></div>
      </div>
    </div>
  </section>

  <aside class="right">
    <div class="tabs">
      <button id="tabPlay" class="active">Playbook</button>
      <button id="tabRules">Rules Update</button>
    </div>

    <div id="panePlay" class="tabPane active">
      <div class="panelTitle">Board options</div>
      <div class="hint">
        Use <b>View</b> to switch between <b>Half Pool</b> (set/6-on-5) and <b>Full Pool</b> (counter, press, transitions).
        <br><b>Flip Attack</b> mirrors everything (tokens + drawings + playback).
        <br>Hotkeys: <b>N</b> edit selected cap number • <b>Delete</b> remove selected.
      </div>

      <div class="row">
        <div class="chip"><input id="toggleHalf" type="checkbox" checked><span>Half line</span></div>
        <div class="chip"><input id="toggle2m" type="checkbox" checked><span>2m</span></div>
        <div class="chip"><input id="toggle5m" type="checkbox"><span>5m</span></div>
        <div class="chip"><input id="toggle6m" type="checkbox" checked><span>6m</span></div>
      </div>

      <div class="row">
        <div class="chip"><input id="swapLines" type="checkbox"><span>Swap 2m/5m colors</span></div>
        <div class="chip"><input id="toggleCages" type="checkbox" checked><span>Show cages</span></div>
        <div class="chip"><input id="toggleAreas" type="checkbox" checked><span>Goal areas</span></div>
      </div>

      <div class="row">
        <button id="addBlueBtn">+ Blue</button>
        <button id="addWhiteBtn">+ White</button>
        <button id="addBallBtn">+ Ball</button>
        <button id="removeBtn" class="danger">Remove Selected</button>
      </div>

      <div class="row">
        <select id="formationSel">
          <option value="6v6">Reset: 6v6</option>
          <option value="6on5">Reset: 6 on 5</option>
          <option value="5on6">Reset: 5 on 6</option>
          <option value="empty">Reset: Empty</option>
        </select>
        <button id="resetFormationBtn">Reset</button>
      </div>

      <div class="panelTitle" style="margin-top:6px;">Save / Share</div>
      <div class="row">
        <input id="playNameInput" type="text" placeholder="Play name (e.g., 6-on-5 Cross)" />
        <button id="saveBtn" class="primary">Save</button>
      </div>

      <div class="row">
        <button id="exportBtn">Export JSON</button>
        <button id="importBtn">Import JSON</button>
      </div>

      <div class="row">
        <button id="shareBtn" class="ok">Copy Share Link</button>
      </div>

      <div class="list" id="playsList"></div>

      <div class="footerNote">
        • Arrow/Circle/Highlight draw on top • Eraser deletes strokes you touch • Record captures moves + marks as steps.
      </div>
    </div>

    <div id="paneRules" class="tabPane">
      <div class="panelTitle">Rules & markings (quick reference)</div>
      <div class="hint">
        This tab is a simple cheat sheet for what the markings mean on the board. (Always follow your league’s official rulebook for exact wording.)
      </div>

      <div class="ruleBox">
        <h3>Markings shown here</h3>
        <ul>
          <li><b>2m</b> (yellow by default): set positioning / restriction reference.</li>
          <li><b>5m</b> (red by default): optional reference line (toggle on/off).</li>
          <li><b>6m</b> (white dashed): modern shot / foul reference (toggle on/off).</li>
          <li><b>Half line</b>: transition reference (full pool) / boundary reference (half view).</li>
        </ul>
      </div>

      <div class="ruleBox">
        <h3>Board features</h3>
        <ul>
          <li><b>Half Pool</b>: best for 6-on-5, set entries, fronting help, post options.</li>
          <li><b>Full Pool</b>: best for counter attack, press, drop shifts, transition defense.</li>
          <li><b>Flip Attack</b>: mirrors everything for “switch ends” without re-drawing.</li>
        </ul>
      </div>

     <div class="footerNote">
  Made by <b>Lucas Ramirez</b> &amp; <b>Dylan Rothenberg</b> for <b>Long Island University Water Polo</b> and all those that could benefit.
</div>

    </div>
  </aside>
</main>

<script>
/***********************
 * Utilities
 ***********************/
const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
const uid = () => Math.random().toString(36).slice(2, 10);
const now = () => performance.now();
const deepClone = (obj)=> JSON.parse(JSON.stringify(obj));
function getCanvasPoint(evt, canvas){
  const rect = canvas.getBoundingClientRect();
  const x = (evt.clientX - rect.left) * (canvas.width / rect.width);
  const y = (evt.clientY - rect.top) * (canvas.height / rect.height);
  return {x,y};
}
function lerp(a,b,t){ return a + (b-a)*t; }
function toB64Url(str){
  return btoa(unescape(encodeURIComponent(str)))
    .replaceAll("+","-").replaceAll("/","_").replaceAll("=","");
}
function fromB64Url(b64){
  const pad = b64.length % 4 ? "=".repeat(4 - (b64.length % 4)) : "";
  const s = (b64 + pad).replaceAll("-","+").replaceAll("_","/");
  return decodeURIComponent(escape(atob(s)));
}
function cssVar(name){
  return getComputedStyle(document.documentElement).getPropertyValue(name).trim();
}

/***********************
 * State
 ***********************/
const state = {
  mode: "move",
  strokeColor: "#69B3E7",
  strokeSize: 6,
  showNumbers: true,

  view: "half",       // "half" or "full"
  goalSide: "left",   // attack direction anchor (flip mirrors)

  tokens: [],
  marks: [],

  recording: false,
  recordedSteps: [],
  stepStartSnapshot: null,

  playing: false,
  playIndex: 0,
  playT0: 0,
  playDurationPerStep: 650,
  originalForRewind: null,

  selectedTokenId: null,

  showHalf: true,
  show2m: true,
  show5m: false,
  show6m: true,
  swapped: false,
  showCages: true,
  showAreas: true,

  poolLengthM: 25,
};

/***********************
 * DOM
 ***********************/
const boardWrap = document.getElementById("boardWrap");
const tokensLayer = document.getElementById("tokensLayer");

const fieldCanvas = document.getElementById("fieldCanvas");
const drawCanvas  = document.getElementById("drawCanvas");
const uiCanvas    = document.getElementById("uiCanvas");

const fctx = fieldCanvas.getContext("2d");
const dctx = drawCanvas.getContext("2d");
const uctx = uiCanvas.getContext("2d");

const modeBtns = {
  move: document.getElementById("modeMove"),
  arrow: document.getElementById("modeArrow"),
  circle: document.getElementById("modeCircle"),
  highlight: document.getElementById("modeHighlight"),
  eraser: document.getElementById("modeEraser"),
};

const strokeColorInput = document.getElementById("strokeColor");
const strokeSizeInput = document.getElementById("strokeSize");

const undoBtn = document.getElementById("undoBtn");
const clearBtn = document.getElementById("clearBtn");

const viewSel = document.getElementById("viewSel");
const flipBtn = document.getElementById("flipBtn");
const pngBtn = document.getElementById("pngBtn");

const numbersBtn = document.getElementById("numbersBtn");
const editNumBtn = document.getElementById("editNumBtn");

const recordBtn = document.getElementById("recordBtn");
const playBtn = document.getElementById("playBtn");
const rewindBtn = document.getElementById("rewindBtn");

const toggleHalf = document.getElementById("toggleHalf");
const toggle2m = document.getElementById("toggle2m");
const toggle5m = document.getElementById("toggle5m");
const toggle6m = document.getElementById("toggle6m");
const swapLines = document.getElementById("swapLines");
const toggleCages = document.getElementById("toggleCages");
const toggleAreas = document.getElementById("toggleAreas");

const addBlueBtn = document.getElementById("addBlueBtn");
const addWhiteBtn = document.getElementById("addWhiteBtn");
const addBallBtn = document.getElementById("addBallBtn");
const removeBtn = document.getElementById("removeBtn");

const formationSel = document.getElementById("formationSel");
const resetFormationBtn = document.getElementById("resetFormationBtn");

const playNameInput = document.getElementById("playNameInput");
const saveBtn = document.getElementById("saveBtn");
const playsList = document.getElementById("playsList");
const exportBtn = document.getElementById("exportBtn");
const importBtn = document.getElementById("importBtn");
const shareBtn = document.getElementById("shareBtn");

// tabs
const tabPlay = document.getElementById("tabPlay");
const tabRules = document.getElementById("tabRules");
const panePlay = document.getElementById("panePlay");
const paneRules = document.getElementById("paneRules");

/***********************
 * Tabs
 ***********************/
function setTab(which){
  const isPlay = which === "play";
  tabPlay.classList.toggle("active", isPlay);
  tabRules.classList.toggle("active", !isPlay);
  panePlay.classList.toggle("active", isPlay);
  paneRules.classList.toggle("active", !isPlay);
}
tabPlay.addEventListener("click", ()=>setTab("play"));
tabRules.addEventListener("click", ()=>setTab("rules"));

/***********************
 * Canvas sizing
 ***********************/
function resizeCanvases(){
  const rect = boardWrap.getBoundingClientRect();
  const w = Math.max(2, Math.floor(rect.width * devicePixelRatio));
  const h = Math.max(2, Math.floor(rect.height * devicePixelRatio));
  for (const c of [fieldCanvas, drawCanvas, uiCanvas]){
    c.width = w; c.height = h;
  }
  redrawField();
  redrawAllMarks();
}
new ResizeObserver(resizeCanvases).observe(boardWrap);
window.addEventListener("resize", resizeCanvases);

/***********************
 * Field drawing
 ***********************/
function redrawField(){
  const w = fieldCanvas.width;
  const h = fieldCanvas.height;

  fctx.setTransform(1,0,0,1,0,0);
  fctx.clearRect(0,0,w,h);

  const twoCol  = state.swapped ? (cssVar("--fiveM") || "rgba(255,77,77,.88)") : (cssVar("--twoM") || "rgba(255,199,44,.92)");
  const fiveCol = state.swapped ? (cssVar("--twoM") || "rgba(255,199,44,.92)") : (cssVar("--fiveM") || "rgba(255,77,77,.88)");
  const sixCol  = cssVar("--sixM") || "rgba(246,247,251,.92)";
  const whiteCol = cssVar("--white") || "rgba(246,247,251,.92)";

  // meters -> x% mapping depends on view
  // Full: 0..25m across width
  // Half: 0..12.5m across width
  const halfLen = state.poolLengthM / 2;
  const spanM = (state.view === "full") ? state.poolLengthM : halfLen;

  function meterToXPctFromGoal(m){
    const pct = (m / spanM) * 100;
    return clamp(pct, 0, 100);
  }

  // vertical line helper. In full view we often draw BOTH ends (mirrored).
  function vLine(xPct, style, widthPx, dashed=false){
    const xTruePct = (state.goalSide === "left") ? xPct : (100 - xPct);
    const x = (xTruePct/100) * w;

    fctx.save();
    fctx.strokeStyle = style;
    fctx.lineWidth = widthPx * devicePixelRatio;
    fctx.lineCap = "butt";
    if (dashed) fctx.setLineDash([10*devicePixelRatio, 8*devicePixelRatio]);
    fctx.beginPath();
    fctx.moveTo(x, 0.08*h);
    fctx.lineTo(x, 0.92*h);
    fctx.stroke();
    fctx.restore();
  }

  // draw goal line(s)
  if (state.view === "half"){
    vLine(0, whiteCol, 4, false);
    if (state.showHalf) vLine(100, whiteCol, 3, false);
    if (state.show2m) vLine(meterToXPctFromGoal(2), twoCol, 3, false);
    if (state.show5m) vLine(meterToXPctFromGoal(5), fiveCol, 3, false);
    if (state.show6m) vLine(meterToXPctFromGoal(6), sixCol, 3, true);
  } else {
    // full pool: both goal lines + center/half line
    vLine(0, whiteCol, 4, false);
    vLine(100, whiteCol, 4, false);
    if (state.showHalf) vLine(50, whiteCol, 3, false);

    // markings from BOTH ends: draw at m and (25 - m)
    if (state.show2m){
      vLine(meterToXPctFromGoal(2), twoCol, 3, false);
      vLine(100 - meterToXPctFromGoal(2), twoCol, 3, false);
    }
    if (state.show5m){
      vLine(meterToXPctFromGoal(5), fiveCol, 3, false);
      vLine(100 - meterToXPctFromGoal(5), fiveCol, 3, false);
    }
    if (state.show6m){
      vLine(meterToXPctFromGoal(6), sixCol, 3, true);
      vLine(100 - meterToXPctFromGoal(6), sixCol, 3, true);
    }
  }

  // Goal areas + cages:
  // Half: only on goal side
  // Full: both ends
  function drawGoalStuff(side){ // side: "left" or "right"
    if (!state.showAreas && !state.showCages) return;

    const isLeft = side === "left";
    const boxW = 0.14*w;
    const boxH = 0.56*h;
    const top = 0.22*h;
    const inset = 0.045*w;
    const xBox = isLeft ? inset : (w - inset - boxW);

    if (state.showAreas){
      fctx.save();
      fctx.strokeStyle = whiteCol;
      fctx.lineWidth = 3*devicePixelRatio;
      fctx.beginPath();
      fctx.roundRect(xBox, top, boxW, boxH, 10*devicePixelRatio);
      fctx.stroke();
      fctx.restore();
    }

    if (state.showCages){
      const cageTop = 0.36*h;
      const cageH   = 0.28*h;
      const cageW   = 0.07*w;
      const inset2 = 0.022*w;
      const xCage = isLeft ? inset2 : (w - inset2 - cageW);

      fctx.save();
      fctx.strokeStyle = "rgba(246,247,251,.95)";
      fctx.lineWidth = 3*devicePixelRatio;
      fctx.fillStyle = "rgba(0,0,0,.10)";
      fctx.beginPath();
      fctx.roundRect(xCage, cageTop, cageW, cageH, 8*devicePixelRatio);
      fctx.fill();
      fctx.stroke();

      // net
      fctx.globalAlpha = 0.55;
      fctx.strokeStyle = "rgba(255,255,255,.22)";
      fctx.lineWidth = 1*devicePixelRatio;
      const step = 10*devicePixelRatio;
      for (let xx = xCage + 3*devicePixelRatio; xx < xCage + cageW - 3*devicePixelRatio; xx += step){
        fctx.beginPath();
        fctx.moveTo(xx, cageTop + 3*devicePixelRatio);
        fctx.lineTo(xx, cageTop + cageH - 3*devicePixelRatio);
        fctx.stroke();
      }
      for (let yy = cageTop + 3*devicePixelRatio; yy < cageTop + cageH - 3*devicePixelRatio; yy += step){
        fctx.beginPath();
        fctx.moveTo(xCage + 3*devicePixelRatio, yy);
        fctx.lineTo(xCage + cageW - 3*devicePixelRatio, yy);
        fctx.stroke();
      }
      fctx.restore();
    }
  }

  if (state.view === "half"){
    drawGoalStuff(state.goalSide);
  } else {
    drawGoalStuff("left");
    drawGoalStuff("right");
  }
}

/***********************
 * Tokens & formations
 ***********************/
function formation6v6(){
  const tokens = [];
  if (state.view === "half"){
    const o = [[22,30],[22,50],[22,70],[35,35],[35,65],[30,50]];
    for (let i=0;i<6;i++) tokens.push({ id: uid(), team:"blue", xPct:o[i][0], yPct:o[i][1], num:String(i+1) });
    const d = [[60,35],[60,50],[60,65],[72,42],[72,58],[68,50]];
    for (let i=0;i<6;i++) tokens.push({ id: uid(), team:"white", xPct:d[i][0], yPct:d[i][1], num:String(i+1) });
    tokens.push({ id: uid(), team:"ball", xPct: 32, yPct: 50, num: "●" });
    return tokens;
  } else {
    // full pool: spread more
    const o = [[28,25],[28,50],[28,75],[40,35],[40,65],[36,50]];
    for (let i=0;i<6;i++) tokens.push({ id: uid(), team:"blue", xPct:o[i][0], yPct:o[i][1], num:String(i+1) });
    const d = [[72,25],[72,50],[72,75],[60,35],[60,65],[64,50]];
    for (let i=0;i<6;i++) tokens.push({ id: uid(), team:"white", xPct:d[i][0], yPct:d[i][1], num:String(i+1) });
    tokens.push({ id: uid(), team:"ball", xPct: 50, yPct: 50, num: "●" });
    return tokens;
  }
}
function formation6on5(){
  const tokens = [];
  if (state.view === "half"){
    const o = [[22,30],[22,50],[22,70],[38,35],[38,65],[32,50]];
    for (let i=0;i<6;i++) tokens.push({ id: uid(), team:"blue", xPct:o[i][0], yPct:o[i][1], num:String(i+1) });
    const d = [[62,35],[62,50],[62,65],[74,42],[74,58]];
    for (let i=0;i<5;i++) tokens.push({ id: uid(), team:"white", xPct:d[i][0], yPct:d[i][1], num:String(i+1) });
    tokens.push({ id: uid(), team:"ball", xPct: 32, yPct: 50, num: "●" });
    return tokens;
  } else {
    const o = [[30,30],[30,50],[30,70],[44,35],[44,65],[38,50]];
    for (let i=0;i<6;i++) tokens.push({ id: uid(), team:"blue", xPct:o[i][0], yPct:o[i][1], num:String(i+1) });
    const d = [[70,35],[70,50],[70,65],[58,42],[58,58]];
    for (let i=0;i<5;i++) tokens.push({ id: uid(), team:"white", xPct:d[i][0], yPct:d[i][1], num:String(i+1) });
    tokens.push({ id: uid(), team:"ball", xPct: 45, yPct: 50, num: "●" });
    return tokens;
  }
}
function formation5on6(){
  const tokens = [];
  if (state.view === "half"){
    const w = [[62,30],[62,50],[62,70],[46,35],[46,65],[52,50]];
    for (let i=0;i<6;i++) tokens.push({ id: uid(), team:"white", xPct:w[i][0], yPct:w[i][1], num:String(i+1) });
    const b = [[22,35],[22,50],[22,65],[10,42],[10,58]];
    for (let i=0;i<5;i++) tokens.push({ id: uid(), team:"blue", xPct:b[i][0], yPct:b[i][1], num:String(i+1) });
    tokens.push({ id: uid(), team:"ball", xPct: 52, yPct: 50, num: "●" });
    return tokens;
  } else {
    const w = [[70,25],[70,50],[70,75],[56,35],[56,65],[62,50]];
    for (let i=0;i<6;i++) tokens.push({ id: uid(), team:"white", xPct:w[i][0], yPct:w[i][1], num:String(i+1) });
    const b = [[30,35],[30,50],[30,65],[42,42],[42,58]];
    for (let i=0;i<5;i++) tokens.push({ id: uid(), team:"blue", xPct:b[i][0], yPct:b[i][1], num:String(i+1) });
    tokens.push({ id: uid(), team:"ball", xPct: 55, yPct: 50, num: "●" });
    return tokens;
  }
}
function formationEmpty(){ return []; }

function renderTokens(){
  tokensLayer.innerHTML = "";
  for (const t of state.tokens){
    const el = document.createElement("div");
    el.className = `token ${t.team}`;
    el.dataset.id = t.id;

    const num = document.createElement("div");
    num.className = "num";
    num.textContent = (t.team === "ball") ? "●" : (state.showNumbers ? (t.num || "") : "");
    el.appendChild(num);

    el.style.left = `${t.xPct}%`;
    el.style.top = `${t.yPct}%`;

    if (state.selectedTokenId === t.id){
      el.style.outline = "3px solid rgba(255,255,255,.85)";
      el.style.outlineOffset = "2px";
    }
    tokensLayer.appendChild(el);
  }
}
function updateTokenNumbers(){
  document.querySelectorAll(".token").forEach(el=>{
    const id = el.dataset.id;
    const t = state.tokens.find(x=>x.id===id);
    if (!t) return;
    el.querySelector(".num").textContent = (t.team === "ball") ? "●" : (state.showNumbers ? (t.num || "") : "");
  });
}

/***********************
 * Marks drawing
 ***********************/
function clearCanvas(ctx){
  ctx.setTransform(1,0,0,1,0,0);
  ctx.clearRect(0,0,ctx.canvas.width,ctx.canvas.height);
}
function drawArrow(ctx, points, color, size){
  if (!points || points.length < 2) return;
  ctx.save();
  ctx.lineCap = "round";
  ctx.lineJoin = "round";
  ctx.strokeStyle = color;
  ctx.lineWidth = size;
  ctx.beginPath();
  ctx.moveTo(points[0].x, points[0].y);
  for (let i=1;i<points.length;i++) ctx.lineTo(points[i].x, points[i].y);
  ctx.stroke();

  const p1 = points[points.length-2];
  const p2 = points[points.length-1];
  const ang = Math.atan2(p2.y - p1.y, p2.x - p1.x);
  const headLen = 14 * devicePixelRatio + size * 0.9;

  ctx.beginPath();
  ctx.moveTo(p2.x, p2.y);
  ctx.lineTo(p2.x - headLen*Math.cos(ang - Math.PI/7), p2.y - headLen*Math.sin(ang - Math.PI/7));
  ctx.moveTo(p2.x, p2.y);
  ctx.lineTo(p2.x - headLen*Math.cos(ang + Math.PI/7), p2.y - headLen*Math.sin(ang + Math.PI/7));
  ctx.stroke();
  ctx.restore();
}
function drawCircle(ctx, cx, cy, r, color, size){
  ctx.save();
  ctx.strokeStyle = color;
  ctx.lineWidth = size;
  ctx.beginPath();
  ctx.arc(cx, cy, r, 0, Math.PI*2);
  ctx.stroke();
  ctx.restore();
}
function drawHighlight(ctx, points, color, size){
  if (!points || points.length < 2) return;
  ctx.save();
  ctx.globalAlpha = 0.28;
  ctx.lineCap = "round";
  ctx.lineJoin = "round";
  ctx.strokeStyle = color;
  ctx.lineWidth = size * 2.2;
  ctx.beginPath();
  ctx.moveTo(points[0].x, points[0].y);
  for (let i=1;i<points.length;i++) ctx.lineTo(points[i].x, points[i].y);
  ctx.stroke();
  ctx.restore();
}
function redrawAllMarks(){
  clearCanvas(dctx);
  clearCanvas(uctx);
  for (const m of state.marks){
    if (m.type === "arrow") drawArrow(dctx, m.points, m.color, m.size);
    if (m.type === "circle") drawCircle(dctx, m.cx, m.cy, m.r, m.color, m.size);
    if (m.type === "highlight") drawHighlight(dctx, m.points, m.color, m.size);
  }
}
function distPointToSegment(px,py,x1,y1,x2,y2){
  const dx=x2-x1, dy=y2-y1;
  if (dx===0 && dy===0) return Math.hypot(px-x1, py-y1);
  const t=((px-x1)*dx+(py-y1)*dy)/(dx*dx+dy*dy);
  const tt=Math.max(0,Math.min(1,t));
  const cx=x1+tt*dx, cy=y1+tt*dy;
  return Math.hypot(px-cx, py-cy);
}
function markHitTest(mark, p, radius){
  if (mark.type === "circle"){
    const d = Math.abs(Math.hypot(p.x-mark.cx, p.y-mark.cy) - mark.r);
    return d <= radius;
  }
  if (mark.type === "arrow" || mark.type === "highlight"){
    const pts = mark.points || [];
    for (let i=1;i<pts.length;i++){
      if (distPointToSegment(p.x,p.y, pts[i-1].x,pts[i-1].y, pts[i].x,pts[i].y) <= radius) return true;
    }
  }
  return false;
}

/***********************
 * Recording / Playback
 ***********************/
function snapshotTokens(){
  return state.tokens.map(t=>({ id:t.id, team:t.team, xPct:t.xPct, yPct:t.yPct, num:t.num }));
}
function applyTokenSnapshot(snap){
  for (const s of snap){
    const t = state.tokens.find(x=>x.id===s.id);
    if (!t) continue;
    t.xPct = s.xPct; t.yPct = s.yPct; t.num = s.num;
  }
  renderTokens();
}
function startRecording(){
  state.recording = true;
  state.recordedSteps = [];
  state.stepStartSnapshot = snapshotTokens();
  recordBtn.classList.add("active");
  recordBtn.textContent = "Stop";
}
function stopRecording(){
  state.recording = false;
  state.stepStartSnapshot = null;
  recordBtn.classList.remove("active");
  recordBtn.textContent = "Record";
}
function addStepFromChanges(changedTokenIds, addedMarks){
  if (!state.recording) return;
  if (changedTokenIds.length === 0 && (!addedMarks || addedMarks.length===0)) return;

  const fromSnap = state.stepStartSnapshot || snapshotTokens();
  const toSnap = snapshotTokens();

  const tokenMoves = [];
  for (const id of changedTokenIds){
    const from = fromSnap.find(t=>t.id===id);
    const to = toSnap.find(t=>t.id===id);
    if (!from || !to) continue;
    tokenMoves.push({ id, from:{xPct:from.xPct,yPct:from.yPct}, to:{xPct:to.xPct,yPct:to.yPct} });
  }

  state.recordedSteps.push({
    t: Date.now(),
    tokenMoves,
    addedMarks: addedMarks ? deepClone(addedMarks) : []
  });

  state.stepStartSnapshot = snapshotTokens();
}
function startPlayback(){
  if (state.playing) return;
  if (!state.recordedSteps || state.recordedSteps.length === 0) return;

  state.playing = true;
  state.playIndex = 0;
  state.playT0 = now();
  state.originalForRewind = { tokens: snapshotTokens(), marks: deepClone(state.marks) };

  playBtn.classList.add("active");
  playBtn.textContent = "Pause";
  playbackLoop();
}
function pausePlayback(){
  state.playing = false;
  playBtn.classList.remove("active");
  playBtn.textContent = "Play";
}
function rewindPlayback(){
  pausePlayback();
  state.playIndex = 0;
  if (state.originalForRewind){
    applyTokenSnapshot(state.originalForRewind.tokens);
    state.marks = deepClone(state.originalForRewind.marks);
    redrawAllMarks();
  }
}
function playbackLoop(){
  if (!state.playing) return;

  const step = state.recordedSteps[state.playIndex];
  if (!step){ pausePlayback(); return; }

  const tNow = now();
  const t = clamp((tNow - state.playT0) / state.playDurationPerStep, 0, 1);

  for (const mv of step.tokenMoves){
    const tok = state.tokens.find(x=>x.id===mv.id);
    if (!tok) continue;
    tok.xPct = lerp(mv.from.xPct, mv.to.xPct, t);
    tok.yPct = lerp(mv.from.yPct, mv.to.yPct, t);
  }
  renderTokens();

  if (t >= 1){
    for (const mv of step.tokenMoves){
      const tok = state.tokens.find(x=>x.id===mv.id);
      if (!tok) continue;
      tok.xPct = mv.to.xPct;
      tok.yPct = mv.to.yPct;
    }
    if (step.addedMarks && step.addedMarks.length){
      for (const m of step.addedMarks) state.marks.push(m);
      redrawAllMarks();
    }
    state.playIndex += 1;
    state.playT0 = now();
  }
  requestAnimationFrame(playbackLoop);
}

/***********************
 * Mode switching
 ***********************/
function setMode(m){
  state.mode = m;
  for (const k of Object.keys(modeBtns)){
    modeBtns[k].classList.toggle("active", k === m);
  }
}
modeBtns.move.addEventListener("click", ()=>setMode("move"));
modeBtns.arrow.addEventListener("click", ()=>setMode("arrow"));
modeBtns.circle.addEventListener("click", ()=>setMode("circle"));
modeBtns.highlight.addEventListener("click", ()=>setMode("highlight"));
modeBtns.eraser.addEventListener("click", ()=>setMode("eraser"));

strokeColorInput.addEventListener("input", (e)=>{ state.strokeColor = e.target.value; });
strokeSizeInput.addEventListener("input", (e)=>{ state.strokeSize = Number(e.target.value); });

numbersBtn.addEventListener("click", ()=>{
  state.showNumbers = !state.showNumbers;
  numbersBtn.textContent = `Cap Numbers: ${state.showNumbers ? "On" : "Off"}`;
  updateTokenNumbers();
});

/***********************
 * Markings toggles
 ***********************/
toggleHalf.addEventListener("change", ()=>{ state.showHalf = toggleHalf.checked; redrawField(); });
toggle2m.addEventListener("change", ()=>{ state.show2m = toggle2m.checked; redrawField(); });
toggle5m.addEventListener("change", ()=>{ state.show5m = toggle5m.checked; redrawField(); });
toggle6m.addEventListener("change", ()=>{ state.show6m = toggle6m.checked; redrawField(); });
toggleCages.addEventListener("change", ()=>{ state.showCages = toggleCages.checked; redrawField(); });
toggleAreas.addEventListener("change", ()=>{ state.showAreas = toggleAreas.checked; redrawField(); });
swapLines.addEventListener("change", ()=>{ state.swapped = swapLines.checked; redrawField(); });

/***********************
 * View (Half / Full)
 ***********************/
function setView(view){
  if (state.playing) pausePlayback();
  if (state.recording) stopRecording();

  state.view = view;
  viewSel.value = view;

  boardWrap.classList.toggle("half", view === "half");
  boardWrap.classList.toggle("full", view === "full");

  // reset tokens to a sensible formation for the new view
  state.selectedTokenId = null;
  state.marks = [];
  state.recordedSteps = [];
  state.tokens = formation6v6();
  renderTokens();

  redrawField();
  redrawAllMarks();
  resizeCanvases();
}
viewSel.addEventListener("change", (e)=> setView(e.target.value));

/***********************
 * Undo / Clear
 ***********************/
undoBtn.addEventListener("click", ()=>{
  state.marks.pop();
  redrawAllMarks();
});
clearBtn.addEventListener("click", ()=>{
  state.marks = [];
  state.recordedSteps = [];
  redrawAllMarks();
});

/***********************
 * Add/remove tokens + selection
 ***********************/
function addToken(team){
  const numDefault = (team==="ball") ? "●" : String((state.tokens.filter(t=>t.team===team).length % 13) + 1);
  state.tokens.push({ id: uid(), team, xPct: 50, yPct: 50, num: numDefault });
  renderTokens();
}
addBlueBtn.addEventListener("click", ()=> addToken("blue"));
addWhiteBtn.addEventListener("click", ()=> addToken("white"));
addBallBtn.addEventListener("click", ()=> addToken("ball"));

removeBtn.addEventListener("click", ()=>{
  if (!state.selectedTokenId) return;
  state.tokens = state.tokens.filter(t=>t.id !== state.selectedTokenId);
  state.selectedTokenId = null;
  renderTokens();
});

tokensLayer.addEventListener("pointerdown", (evt)=>{
  const tokenEl = evt.target.closest(".token");
  if (!tokenEl) { state.selectedTokenId = null; renderTokens(); return; }
  state.selectedTokenId = tokenEl.dataset.id;
  renderTokens();
});

function editSelectedNumber(){
  if (!state.selectedTokenId) return;
  const t = state.tokens.find(x=>x.id===state.selectedTokenId);
  if (!t || t.team === "ball") return;
  const val = prompt("Cap number:", t.num || "");
  if (val === null) return;
  t.num = val.trim();
  renderTokens();
}
editNumBtn.addEventListener("click", editSelectedNumber);
tokensLayer.addEventListener("dblclick", (evt)=>{
  const tokenEl = evt.target.closest(".token");
  if (!tokenEl) return;
  state.selectedTokenId = tokenEl.dataset.id;
  renderTokens();
  editSelectedNumber();
});
window.addEventListener("keydown", (e)=>{
  if (e.key === "Delete" || e.key === "Backspace"){
    if (state.selectedTokenId){
      state.tokens = state.tokens.filter(t=>t.id !== state.selectedTokenId);
      state.selectedTokenId = null;
      renderTokens();
    }
  }
  if (e.key.toLowerCase() === "n") editSelectedNumber();
});

resetFormationBtn.addEventListener("click", ()=>{
  const v = formationSel.value;
  state.selectedTokenId = null;
  state.marks = [];
  state.recordedSteps = [];
  if (v==="6v6") state.tokens = formation6v6();
  if (v==="6on5") state.tokens = formation6on5();
  if (v==="5on6") state.tokens = formation5on6();
  if (v==="empty") state.tokens = formationEmpty();
  redrawAllMarks();
  renderTokens();
});

/***********************
 * Drag tokens
 ***********************/
let drag = null;
function pointerToPct(evt){
  const rect = tokensLayer.getBoundingClientRect();
  const x = clamp((evt.clientX - rect.left) / rect.width, 0, 1);
  const y = clamp((evt.clientY - rect.top) / rect.height, 0, 1);
  return { xPct: x*100, yPct: y*100 };
}
tokensLayer.addEventListener("pointerdown", (evt)=>{
  const target = evt.target.closest(".token");
  if (!target) return;
  if (state.mode !== "move") return;
  if (state.playing) return;

  const id = target.dataset.id;
  const tok = state.tokens.find(t=>t.id===id);
  if (!tok) return;

  tokensLayer.setPointerCapture(evt.pointerId);
  drag = { id, changed: false };
});
tokensLayer.addEventListener("pointermove", (evt)=>{
  if (!drag) return;
  const tok = state.tokens.find(t=>t.id===drag.id);
  if (!tok) return;

  const p = pointerToPct(evt);
  tok.xPct = p.xPct;
  tok.yPct = p.yPct;
  drag.changed = true;
  renderTokens();
});
tokensLayer.addEventListener("pointerup", ()=>{
  if (!drag) return;
  const id = drag.id;
  const changed = drag.changed;
  drag = null;

  if (state.recording && changed){
    addStepFromChanges([id], []);
  }
});

/***********************
 * Drawing interactions
 ***********************/
let drawing = null;
let marksAddedThisGesture = [];

function beginDraw(evt){
  if (state.mode === "move") return;
  if (state.playing) return;

  const p = getCanvasPoint(evt, drawCanvas);

  if (state.mode === "eraser"){
    const hitRadius = 14 * devicePixelRatio;
    const before = state.marks.length;
    state.marks = state.marks.filter(m => !markHitTest(m, p, hitRadius));
    if (state.marks.length !== before) redrawAllMarks();
    return;
  }

  marksAddedThisGesture = [];

  if (state.mode === "arrow"){
    drawing = { type:"arrow", color: state.strokeColor, size: state.strokeSize*devicePixelRatio, points:[p] };
  } else if (state.mode === "highlight"){
    drawing = { type:"highlight", color: state.strokeColor, size: state.strokeSize*devicePixelRatio, points:[p] };
  } else if (state.mode === "circle"){
    drawing = { type:"circle", color: state.strokeColor, size: state.strokeSize*devicePixelRatio, cx:p.x, cy:p.y, r:1, start:p };
  }

  redrawAllMarks();
  previewDraw();
}
function updateDraw(evt){
  if (!drawing) return;
  const p = getCanvasPoint(evt, drawCanvas);

  if (drawing.type === "arrow" || drawing.type === "highlight"){
    drawing.points.push(p);
  } else if (drawing.type === "circle"){
    const dx = p.x - drawing.start.x;
    const dy = p.y - drawing.start.y;
    drawing.r = Math.sqrt(dx*dx + dy*dy);
  }

  redrawAllMarks();
  previewDraw();
}
function endDraw(){
  if (!drawing) return;

  let commit = false;
  if ((drawing.type === "arrow" || drawing.type === "highlight") && drawing.points.length >= 2) commit = true;
  if (drawing.type === "circle" && drawing.r > 3*devicePixelRatio) commit = true;

  if (commit){
    const mark = deepClone(drawing);
    state.marks.push(mark);
    marksAddedThisGesture.push(mark);
    redrawAllMarks();

    if (state.recording){
      addStepFromChanges([], marksAddedThisGesture);
    }
  } else {
    redrawAllMarks();
  }

  drawing = null;
  marksAddedThisGesture = [];
  clearCanvas(uctx);
}
function previewDraw(){
  clearCanvas(uctx);
  if (!drawing) return;

  if (drawing.type === "arrow") drawArrow(uctx, drawing.points, drawing.color, drawing.size);
  if (drawing.type === "highlight") drawHighlight(uctx, drawing.points, drawing.color, drawing.size);
  if (drawing.type === "circle") drawCircle(uctx, drawing.cx, drawing.cy, drawing.r, drawing.color, drawing.size);
}

boardWrap.addEventListener("pointerdown", (evt)=>{
  if (evt.target.closest(".token")) return;
  boardWrap.setPointerCapture(evt.pointerId);
  beginDraw(evt);
});
boardWrap.addEventListener("pointermove", (evt)=> updateDraw(evt));
boardWrap.addEventListener("pointerup", ()=> endDraw());
boardWrap.addEventListener("pointercancel", ()=> endDraw());

/***********************
 * Record / Play / Rewind
 ***********************/
recordBtn.addEventListener("click", ()=>{
  if (state.playing) return;
  if (!state.recording) startRecording();
  else stopRecording();
});
playBtn.addEventListener("click", ()=>{
  if (!state.playing) startPlayback();
  else pausePlayback();
});
rewindBtn.addEventListener("click", rewindPlayback);

/***********************
 * Flip Attack (mirrors tokens + marks + steps)
 ***********************/
function flipPct(p){ return 100 - p; }
function flipXCanvas(x){ return drawCanvas.width - x; }

function flipAll(){
  state.goalSide = (state.goalSide === "left") ? "right" : "left";

  for (const t of state.tokens){
    t.xPct = flipPct(t.xPct);
  }

  for (const m of state.marks){
    if (m.type === "circle"){
      m.cx = flipXCanvas(m.cx);
    } else if (m.type === "arrow" || m.type === "highlight"){
      for (const pt of m.points) pt.x = flipXCanvas(pt.x);
    }
  }

  for (const step of state.recordedSteps){
    for (const mv of step.tokenMoves){
      mv.from.xPct = flipPct(mv.from.xPct);
      mv.to.xPct   = flipPct(mv.to.xPct);
    }
    if (step.addedMarks){
      for (const m of step.addedMarks){
        if (m.type === "circle"){
          m.cx = flipXCanvas(m.cx);
        } else if (m.type === "arrow" || m.type === "highlight"){
          for (const pt of m.points) pt.x = flipXCanvas(pt.x);
        }
      }
    }
  }

  redrawField();
  redrawAllMarks();
  renderTokens();
}
flipBtn.addEventListener("click", ()=>{
  if (state.playing) return;
  flipAll();
});

/***********************
 * PNG export
 ***********************/
pngBtn.addEventListener("click", ()=>{
  const rect = boardWrap.getBoundingClientRect();
  const w = Math.floor(rect.width * devicePixelRatio);
  const h = Math.floor(rect.height * devicePixelRatio);

  const tmp = document.createElement("canvas");
  tmp.width = w; tmp.height = h;
  const ctx = tmp.getContext("2d");

  const topCol = getComputedStyle(document.documentElement).getPropertyValue("--poolTop").trim() || "#0e4ea8";
  const botCol = getComputedStyle(document.documentElement).getPropertyValue("--poolBot").trim() || "#0b3f86";
  const grad = ctx.createLinearGradient(0,0,0,h);
  grad.addColorStop(0, topCol);
  grad.addColorStop(1, botCol);
  ctx.fillStyle = grad;
  ctx.fillRect(0,0,w,h);

  ctx.save();
  ctx.strokeStyle = "rgba(246,247,251,.92)";
  ctx.lineWidth = 3*devicePixelRatio;
  const inset = 0.04;
  ctx.beginPath();
  ctx.roundRect(inset*w, inset*h, w-2*inset*w, h-2*inset*h, 12*devicePixelRatio);
  ctx.stroke();
  ctx.restore();

  ctx.drawImage(fieldCanvas, 0, 0);
  ctx.drawImage(drawCanvas, 0, 0);

  for (const t of state.tokens){
    const x = (t.xPct/100) * w;
    const y = (t.yPct/100) * h;

    if (t.team === "ball"){
      ctx.beginPath();
      ctx.fillStyle = "rgba(255,199,44,.98)";
      ctx.arc(x,y, 14*devicePixelRatio, 0, Math.PI*2);
      ctx.fill();
      ctx.lineWidth = 2*devicePixelRatio;
      ctx.strokeStyle = "rgba(255,255,255,.75)";
      ctx.stroke();
      continue;
    }

    ctx.beginPath();
    ctx.fillStyle = (t.team==="blue") ? "rgba(105,179,231,.92)" : "rgba(246,247,251,.95)";
    ctx.arc(x,y, 22*devicePixelRatio, 0, Math.PI*2);
    ctx.fill();
    ctx.lineWidth = 2*devicePixelRatio;
    ctx.strokeStyle = "rgba(255,255,255,.65)";
    ctx.stroke();

    if (state.showNumbers){
      ctx.fillStyle = (t.team==="blue") ? "#081226" : "#0b1220";
      ctx.font = `${16*devicePixelRatio}px Arial`;
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText(t.num || "", x, y);
    }
  }

  const a = document.createElement("a");
  a.download = (state.view === "full") ? "waterpolo-fullpool.png" : "waterpolo-halfpool.png";
  a.href = tmp.toDataURL("image/png");
  a.click();
});

/***********************
 * Save / Load plays (local)
 ***********************/
const STORAGE_KEY = "wp_playbook_v2";

function loadAllPlays(){
  try{ return JSON.parse(localStorage.getItem(STORAGE_KEY) || "[]"); }
  catch{ return []; }
}
function saveAllPlays(plays){
  localStorage.setItem(STORAGE_KEY, JSON.stringify(plays));
}
function currentPlayState(){
  return {
    version: 2,
    savedAt: new Date().toISOString(),
    view: state.view,
    goalSide: state.goalSide,
    showNumbers: state.showNumbers,
    showHalf: state.showHalf,
    show2m: state.show2m,
    show5m: state.show5m,
    show6m: state.show6m,
    swapped: state.swapped,
    showCages: state.showCages,
    showAreas: state.showAreas,
    tokens: snapshotTokens(),
    marks: deepClone(state.marks),
    recordedSteps: deepClone(state.recordedSteps),
  };
}
function applyPlayState(ps){
  state.view = ps.view || "half";
  state.goalSide = ps.goalSide || "left";
  state.showNumbers = (ps.showNumbers !== false);

  state.showHalf = (ps.showHalf !== false);
  state.show2m = (ps.show2m !== false);
  state.show5m = !!ps.show5m;
  state.show6m = (ps.show6m !== false);
  state.swapped = !!ps.swapped;
  state.showCages = (ps.showCages !== false);
  state.showAreas = (ps.showAreas !== false);

  viewSel.value = state.view;
  boardWrap.classList.toggle("half", state.view === "half");
  boardWrap.classList.toggle("full", state.view === "full");

  numbersBtn.textContent = `Cap Numbers: ${state.showNumbers ? "On" : "Off"}`;

  toggleHalf.checked = state.showHalf;
  toggle2m.checked = state.show2m;
  toggle5m.checked = state.show5m;
  toggle6m.checked = state.show6m;
  swapLines.checked = state.swapped;
  toggleCages.checked = state.showCages;
  toggleAreas.checked = state.showAreas;

  state.tokens = ps.tokens || formation6v6();
  state.marks = ps.marks || [];
  state.recordedSteps = ps.recordedSteps || [];

  state.selectedTokenId = null;
  renderTokens();
  redrawAllMarks();
  resizeCanvases();
  redrawField();
}
function refreshPlaysList(){
  const plays = loadAllPlays();
  playsList.innerHTML = "";
  if (plays.length === 0){
    playsList.innerHTML = `<div class="hint">No saved plays yet. Save one above.</div>`;
    return;
  }

  for (const p of plays.sort((a,b)=> (b.savedAt||"").localeCompare(a.savedAt||""))){
    const row = document.createElement("div");
    row.className = "playItem";

    const name = document.createElement("div");
    name.className = "playName";
    name.textContent = p.name || "Untitled";

    const btns = document.createElement("div");
    btns.className = "miniBtns";

    const load = document.createElement("button");
    load.textContent = "Load";
    load.addEventListener("click", ()=>{
      pausePlayback();
      stopRecording();
      applyPlayState(p.data);
      setTab("play");
    });

    const del = document.createElement("button");
    del.textContent = "Delete";
    del.classList.add("danger");
    del.addEventListener("click", ()=>{
      const plays2 = loadAllPlays().filter(x=>x.id !== p.id);
      saveAllPlays(plays2);
      refreshPlaysList();
    });

    btns.appendChild(load);
    btns.appendChild(del);

    row.appendChild(name);
    row.appendChild(btns);
    playsList.appendChild(row);
  }
}
saveBtn.addEventListener("click", ()=>{
  const name = (playNameInput.value || "").trim() || `Play ${new Date().toLocaleString()}`;
  const plays = loadAllPlays();
  plays.push({ id: uid(), name, savedAt: new Date().toISOString(), data: currentPlayState() });
  saveAllPlays(plays);
  refreshPlaysList();
  playNameInput.value = "";
});

exportBtn.addEventListener("click", async ()=>{
  const json = JSON.stringify(currentPlayState(), null, 2);
  try{
    await navigator.clipboard.writeText(json);
    alert("Export JSON copied to clipboard ✅");
  }catch{
    prompt("Copy your JSON:", json);
  }
});
importBtn.addEventListener("click", ()=>{
  const json = prompt("Paste exported JSON here:");
  if (!json) return;
  try{
    const data = JSON.parse(json);
    pausePlayback();
    stopRecording();
    applyPlayState(data);
  }catch{
    alert("Invalid JSON.");
  }
});

shareBtn.addEventListener("click", async ()=>{
  const payload = toB64Url(JSON.stringify(currentPlayState()));
  const url = new URL(window.location.href);
  url.hash = "play=" + payload;

  try{
    await navigator.clipboard.writeText(url.toString());
    alert("Share link copied ✅");
  }catch{
    prompt("Copy this link:", url.toString());
  }
});
function loadFromHashIfPresent(){
  const h = window.location.hash || "";
  const m = h.match(/play=([^&]+)/);
  if (!m) return false;
  try{
    const decoded = fromB64Url(m[1]);
    const data = JSON.parse(decoded);
    applyPlayState(data);
    return true;
  }catch{
    return false;
  }
}

/***********************
 * Init
 ***********************/
function init(){
  setMode("move");
  state.strokeColor = strokeColorInput.value;
  state.strokeSize = Number(strokeSizeInput.value);

  // initial view
  setView("half");

  refreshPlaysList();
  loadFromHashIfPresent();
}
init();
</script>
</body>
</html>
